<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tasks &mdash; BMI3D 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="BMI3D 1.0 documentation" href="index.html" />
    <link rel="next" title="The Database" href="database.html" />
    <link rel="prev" title="Assumed Python knowledge" href="prereqs.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="database.html" title="The Database"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="prereqs.html" title="Assumed Python knowledge"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">BMI3D 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tasks">
<span id="id1"></span><h1>Tasks<a class="headerlink" href="#tasks" title="Permalink to this headline">¶</a></h1>
<p>All tasks boil down to a finite state machine (FSM), a set of states and the rules for moving between those states. Every task is a subclass of the <tt class="xref py py-class docutils literal"><span class="pre">Experiment</span></tt> class. Parameters can be either hard-coded or defined at runtime (e.g., to adjust the difficulty of the task without needing to change the code).</p>
<div class="section" id="defining-tasks">
<h2>Defining tasks<a class="headerlink" href="#defining-tasks" title="Permalink to this headline">¶</a></h2>
<p><strong>Specifying the finite state machine (FSM)</strong></p>
<p>A state can be thought of as a discrete part of the task which is triggered by some condition being met and ends when some other condition is met (e.g., waiting for fixation, or a target hold). The state transition definition describes the structure of the task. For each possible state it lists all the possible subsequent states and the events that trigger those transitions.</p>
<p>For example, the parent class <tt class="xref py py-class docutils literal"><span class="pre">Experiment</span></tt> has the following structure, where ovals represent states and arrows represent transitions:</p>
<img alt="_images/states.png" src="_images/states.png" />
<p>A state transition definition is written in the code as a nested dictionary with the name <tt class="docutils literal"><span class="pre">status</span></tt> that delineates all possible event-next state transitions that could occur from within each state. It is usually the very first thing defined in a task class. For the task illustrated above, the state transition definition in the code looks like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">status</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">wait</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">start_trial</span><span class="o">=</span><span class="s">&quot;trial&quot;</span><span class="p">,</span> <span class="n">premature</span><span class="o">=</span><span class="s">&quot;penalty&quot;</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">),</span>
        <span class="n">trial</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">correct</span><span class="o">=</span><span class="s">&quot;reward&quot;</span><span class="p">,</span> <span class="n">incorrect</span><span class="o">=</span><span class="s">&quot;penalty&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="s">&quot;penalty&quot;</span><span class="p">),</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">post_reward</span><span class="o">=</span><span class="s">&quot;wait&quot;</span><span class="p">),</span>
        <span class="n">penalty</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">post_penalty</span><span class="o">=</span><span class="s">&quot;wait&quot;</span><span class="p">),</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, a slightly more abstracted declaration might be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">riglib.experiment</span> <span class="kn">import</span> <span class="n">FSMTable</span><span class="p">,</span> <span class="n">StateTransitions</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">FSMTable</span><span class="p">(</span>
        <span class="n">wait</span> <span class="o">=</span> <span class="n">StateTransitions</span><span class="p">(</span><span class="n">start_trial</span><span class="o">=</span><span class="s">&quot;trial&quot;</span><span class="p">,</span> <span class="n">premature</span><span class="o">=</span><span class="s">&quot;penalty&quot;</span><span class="p">,</span> <span class="n">stoppable</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span>
        <span class="n">trial</span> <span class="o">=</span> <span class="n">StateTransitions</span><span class="p">(</span><span class="n">correct</span><span class="o">=</span><span class="s">&quot;reward&quot;</span><span class="p">,</span> <span class="n">incorrect</span><span class="o">=</span><span class="s">&quot;penalty&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="s">&quot;penalty&quot;</span><span class="p">),</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="n">StateTransitions</span><span class="p">(</span><span class="n">post_reward</span><span class="o">=</span><span class="s">&quot;wait&quot;</span><span class="p">),</span>
        <span class="n">penalty</span> <span class="o">=</span> <span class="n">StateTransitions</span><span class="p">(</span><span class="n">post_penalty</span><span class="o">=</span><span class="s">&quot;wait&quot;</span><span class="p">),</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>There are four states in this task (<em>wait</em>, <em>trial</em>, <em>reward</em>, and <em>penalty</em>). Each state name is entered in the <tt class="docutils literal"><span class="pre">status</span></tt> dictionary as a key with another dictionary for the value. That dictionary in turn contains keys which are the names of events that trigger state transitions (they can also be thought of as tests that must be passed in order to move to the next state), and values which are the names of the states that follow these events. So while this task is in the <em>wait</em> state, it can do one of four things at any moment: if the <em>start_trial</em> test is passed, it transitions to the <em>trial</em> state; if the <em>premature</em> test is passed, it transitions to the <em>penalty</em> state; if the experiment receives a stop signal from the server, the task ends; if none of these things occur, it remains in the <em>wait</em> state.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The key/value pair <tt class="docutils literal"><span class="pre">stop</span> <span class="pre">=</span> <span class="pre">None</span></tt> can be inserted into any state where you would like the server to be able to stop the task immediately. If a state&#8217;s dictionary does not contain this entry and a stop command is received, the task will continue until it reaches a state that does contain it. Make sure at least one state has an exit transition, otherwise you will not be able to stop execution of your task! If you use the <tt class="docutils literal"><span class="pre">StateTransitions</span></tt>, states are assumed to be stoppable by default (the more common condition). Sometimes states should not be stoppable, e.g., if during that state you run an actuator and you need to keep the task running until the action is complete.</p>
</div>
</div></blockquote>
<p><strong>Runtime-configurable parameters</strong></p>
<p>Parameters which you want to be set by the experimenter at runtime can be defined as <a class="reference external" href="http://code.enthought.com/projects/traits/">Traits</a> within the task class definition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># settable traits</span>
<span class="n">reward_time</span> <span class="o">=</span> <span class="n">traits</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s">&quot;Length of juice reward&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The first argument is the default value for the trait and the second is a docstring that will show up when the mouse hovers over that parameter in the browser interface. The name of the variable will be the text the user sees in the list of parameters (in this case <tt class="docutils literal"><span class="pre">reward_time</span></tt>). Several different traits types are currently supported:</p>
<ul>
<li><dl class="first docutils">
<dt>Float, Tuple, Array, String</dt>
<dd><p class="first last">These show up as text entry fields, or multiple text-entry fields for Tuple/Array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Bool</dt>
<dd><p class="first last">These will show up as checkboxes</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Instance</dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">traits.Instance</span></tt>-type traits are used for selecting the Decoder, for example. They are useful when the datatype of the thing you want to select is represented by some custom class and you want to be able to select directly from a list of objects. In the current implementation, the object type (e.g., riglib.bmi.Decoder) must correspond to a database model (e.g., models.Decoder). A drop-down list in the GUI is populated with recently created models.Decoder instances. This association is made through db.namelist.instance_to_model. When data from the GUI is submitted back to the server, the object corresponding to the database record is retreived (db.json_param.norm_trait).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Enum</dt>
<dd><p class="first">Enum traits provide an alternative way to Instance traits to create a drop-down menu of options on the web interface. If you wish to add an Enum attribute ATTR to a task, you must also specify ATTR_options as a list of string options to select from. This is due to a deficiency in the way traits.Enum objects are created in the version of traits currently being used; there appears to be no way to extract the possible traits from the Enum object.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This trait type still works, but is no longer the best way to achieve the same functionality</p>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>OptionsList</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">OptionsList</span></tt> traits are custom traits for this library, which serve the same function as Enum traits but without the circuswork of the need to declare the set of options in another variable. An example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plant_type</span> <span class="o">=</span> <span class="n">traits</span><span class="o">.</span><span class="n">OptionsList</span><span class="p">(</span><span class="o">*</span><span class="n">plantlist</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">bmi3d_input_options</span><span class="o">=</span><span class="n">plantlist</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
<p class="last">in which another kwarg, <tt class="docutils literal"><span class="pre">bmi3d_input_options</span></tt> should be an iterable object which contains the available options</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>DataFile</dt>
<dd><p class="first">DataFile traits are similar to Instance traits, but they&#8217;re an upgrade to the Instance traits since you do not have to dig into <tt class="docutils literal"><span class="pre">namelist.py</span></tt> or <tt class="docutils literal"><span class="pre">db/tracker/models.py</span></tt> in order for the list to be populated properly. To make a DataFile trait</p>
<blockquote class="last">
<div><ol class="arabic">
<li><p class="first">all data files must be associated with a system. So make a new system, e.g., the <tt class="docutils literal"><span class="pre">'misc'</span></tt> system:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">db.tracker</span> <span class="kn">import</span> <span class="n">models</span>
<span class="n">data_sys</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">System</span><span class="o">.</span><span class="n">make_new_sys</span><span class="p">(</span><span class="s">&#39;misc&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<p>if the system already exists, then the code above will not do anything, so you can safely always try to make the new system</p>
<ol class="arabic" start="2">
<li><p class="first">Save the object to a pickle file in the appropriate location, and create a DataFile object to keep track of the file location:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">data_sys</span><span class="o">.</span><span class="n">save_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">obj_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">entry_id</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Add a &#8220;DataFile&#8221; trait to the task. An example might be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">test_file</span> <span class="o">=</span> <span class="n">traits</span><span class="o">.</span><span class="n">DataFile</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s">&#39;test&#39;</span><span class="p">,</span> <span class="n">bmi3d_query_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">system__name</span><span class="o">=</span><span class="s">&#39;misc&#39;</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ol>
<p>The keyword argument <tt class="docutils literal"><span class="pre">bmi3d_query_kwargs</span></tt> contains any Django filter criteria you&#8217;d like to apply to filter out irrelevant options. In this case, the datafiles presented to the user in the browser will only be associated with the system &#8216;misc&#8217;</p>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
<p><strong>Making a new type of trait</strong>
[This section is still incomplete]</p>
<p>These things need consideration if you&#8217;re making a new type of trait</p>
<blockquote>
<div>riglib.experiment.__init__
db.tracker.models.Task.to_json()
parse_traits.js
db.json_param.norm_trait # if necessary</div></blockquote>
</div>
<div class="section" id="instantiating-tasks">
<h2>Instantiating tasks<a class="headerlink" href="#instantiating-tasks" title="Permalink to this headline">¶</a></h2>
<p>There&#8217;s a little bit more to instantiating a task object tha normally required with a python object. For instances of <tt class="docutils literal"><span class="pre">riglib.experiment.Experiment</span></tt>, there are three different initialization methods which must all be executed</p>
<ol class="arabic">
<li><dl class="classmethod">
<dt id="riglib.experiment.Experiment.pre_init">
<em class="property">classmethod </em><tt class="descclassname">Experiment.</tt><tt class="descname">pre_init</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#riglib.experiment.Experiment.pre_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Jobs to do before creating the task object go here (or this method should be overridden in child classes).
Examples might include sending a trigger to start a recording device (e.g., neural system), since you might want
recording to be guaranteed to start before any task event loop activity occurs.</p>
</dd></dl>

</li>
<li><dl class="method">
<dt id="riglib.experiment.Experiment.__init__">
<tt class="descclassname">Experiment.</tt><tt class="descname">__init__</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#riglib.experiment.Experiment.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for Experiment. This is the standard python object constructor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kwargs: optional keyword-arguments</strong> :</p>
<blockquote>
<div><p>Any user-specified parameters for experiment traits, to be passed to the traits.HasTraits parent.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>Experiment instance</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</li>
<li><dl class="method">
<dt id="riglib.experiment.Experiment.init">
<tt class="descclassname">Experiment.</tt><tt class="descname">init</tt><big>(</big><big>)</big><a class="headerlink" href="#riglib.experiment.Experiment.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization method to run <em>after</em> object construction (see self.start). 
This may be necessary in some cases where features are used with multiple inheritance to extend tasks 
(this is the standard way of creating custom base experiment + features classes through the browser interface). 
With multiple inheritance, it&#8217;s difficult/annoying to make guarantees about the order of operations for 
each of the individual __init__ functions from each of the parents. Instead, this function runs after all the 
__init__ functions have finished running if any subsequent initialization is necessary before the main event loop 
can execute properly. Examples include initialization of the decoder state/parameters.</p>
</dd></dl>

</li>
</ol>
<p>If no initialization steps are necessary for the task, the <em>__init__</em> method can be omitted (because it will automatically inherit the parent <em>__init__</em> method). This is true of the other special methods as well; however, if an <em>__init__</em> method is included, it MUST contain a call to the parent method, whereas the rest of the special methods may be written to replace the parent methods if desired.</p>
</div>
<div class="section" id="order-of-operations-while-the-task-is-running">
<h2>Order of operations while the task is running<a class="headerlink" href="#order-of-operations-while-the-task-is-running" title="Permalink to this headline">¶</a></h2>
<p><strong>_start_</strong></p>
<p><em>_start_</em> methods specify actions to be performed once at the onset of a new state:</p>
<dl class="docutils">
<dt>def _start_wait(self):</dt>
<dd>super(TargetCapture, self)._start_wait()
#set target color
self.origin_target.color = (1,0,0,.5)
#hide target from previous trial
self.origin_target.detach()
self.requeue()</dd>
</dl>
<p>In the above example, every time the task enters the <em>wait</em> state, the origin target&#8217;s color changes and the target is hidden from the screen, in addition to whatever actions are already performed by the parent class&#8217; <em>_start_wait</em> method.</p>
<p>The full name of the method should always be the <tt class="docutils literal"><span class="pre">_start_</span></tt> prefix followed by a state name that appears in the state transition definition, and the method should take <tt class="docutils literal"><span class="pre">self</span></tt> as its sole argument. (These two rules apply to <em>_while_</em> and <em>_end_</em> methods as well.)</p>
<p><strong>_while_</strong></p>
<p><em>_while_</em> methods specify actions to be repeated (usually once per frame) while the task is in a state. Here, the cursor position is being constantly updated during the <em>wait</em> state:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_while_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">update_cursor</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>_end_</strong></p>
<p><em>_end_</em> methods specify actions to be performed once at the end of a state, just before the task transitions to the next state. In this example, the origin target changes color once a target hold is complete:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_end_origin_hold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c">#change target color</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">origin_target</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>_test_</strong></p>
<p><em>_test_</em> methods define the criteria for state transitions. They are called constantly in the background during corresponding states, and must always return a boolean value. When a <em>_test_</em> method returns <tt class="docutils literal"><span class="pre">True</span></tt>, a transition to the state specified in the state transition definition is triggered. <em>_test_</em> methods must be named with the prefix <tt class="docutils literal"><span class="pre">_test_</span></tt> followed by one of the event names listed in the state transition definition, and they always have two arguments: <tt class="docutils literal"><span class="pre">self</span></tt> and <tt class="docutils literal"><span class="pre">ts</span></tt>, which is a variable containing the elapsed time in seconds since the onset of the current state. The following <em>_test_</em> method returns <tt class="docutils literal"><span class="pre">True</span></tt> when the elapsed time in the current state (<em>origin_hold</em>) exceeds the constant value <em>origin_hold_time</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_test_hold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ts</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin_hold_time</span>
</pre></div>
</div>
<p><strong>_cycle</strong></p>
<dl class="method">
<dt id="riglib.experiment.Experiment._cycle">
<tt class="descclassname">Experiment.</tt><tt class="descname">_cycle</tt><big>(</big><big>)</big><a class="headerlink" href="#riglib.experiment.Experiment._cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Code that needs to run every task loop iteration goes here</p>
</dd></dl>

</div>
<div class="section" id="saving-task-data">
<h2>Saving task data<a class="headerlink" href="#saving-task-data" title="Permalink to this headline">¶</a></h2>
<p>Two types of data saving are currently supported:
1) Saving a variable which could change on every clock tick of the FSM
2) Saving a static variable</p>
<p>Variables you wish to save every FSM iteration must be declared prior to starting the task. The base experiment class has an attribute &#8216;dtype&#8217;, and each new variable to save must be added to this list using the experiment.Experiment.add_dtype method.</p>
<p>To actually save the variable (suppose your variable is named &#8216;data&#8217;), sometime during the execution of the &#8216;_cycle&#8217; method of your task, you must do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">task_data</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_value</span>
</pre></div>
</div>
<p>Important note: in child classes, you must do this <em>before</em> calling the <tt class="docutils literal"><span class="pre">super</span></tt> _cycle method to ensure that your data is saved properly. This is because the final _cycle in the method resolution order is the experiment.Experiment._cycle method, which will send your task_data to any registered sinks. So if you do not set the variable beforehand, it may appear as the data you have saved to file is off by one timestep.</p>
</div>
<div class="section" id="cleaning-up-tasks">
<h2>Cleaning up tasks<a class="headerlink" href="#cleaning-up-tasks" title="Permalink to this headline">¶</a></h2>
<p>Similar to the higher than normal complexity of instantiating a task object, there are a couple of methods which also need to execute if you want your task data to be saved properly</p>
<dl class="method">
<dt id="riglib.experiment.Experiment.cleanup">
<tt class="descclassname">Experiment.</tt><tt class="descname">cleanup</tt><big>(</big><em>database</em>, <em>saveid</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#riglib.experiment.Experiment.cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Commands to execute at the end of a task.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>database</strong> : object</p>
<blockquote>
<div><p>Needs to have the methods save_bmi, save_data, etc. For instance, the db.tracker.dbq module or an RPC representation of the database</p>
</div></blockquote>
<p><strong>saveid</strong> : int</p>
<blockquote>
<div><p>TaskEntry database record id to link files/data to</p>
</div></blockquote>
<p><strong>kwargs</strong> : optional dict arguments</p>
<blockquote>
<div><p>Optional arguments to dbq methods. NOTE: kwargs cannot be used when &#8216;database&#8217; is an RPC object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>None</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="riglib.experiment.Experiment.cleanup_hdf">
<tt class="descclassname">Experiment.</tt><tt class="descname">cleanup_hdf</tt><big>(</big><big>)</big><a class="headerlink" href="#riglib.experiment.Experiment.cleanup_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for adding data to hdf file after hdf sink is closed by 
system at end of task. The HDF file is re-opened and any extra task 
data kept in RAM is written</p>
</dd></dl>

</div>
<div class="section" id="task-trials-and-logging">
<h2>Task &#8220;trials&#8221; and logging<a class="headerlink" href="#task-trials-and-logging" title="Permalink to this headline">¶</a></h2>
<p>The base experiment class is a barebones FSM implementation. Two useful extensions are the <tt class="docutils literal"><span class="pre">LogExperiment</span></tt> and the <tt class="docutils literal"><span class="pre">Sequence</span></tt> classes. The LogExperiment extends Experiment by keeping track of (i.e., logging) events and state transitions. This provides the ability to calculate stats about state occurrences (e.g., successes per minute) as well as save the log to the database during &#8220;cleanup&#8221; time.</p>
<p>The <tt class="docutils literal"><span class="pre">Sequence</span></tt> class further extends <tt class="docutils literal"><span class="pre">LogExperiment</span></tt> by making the &#8220;wait&#8221; state a special state. The constructor for the Sequence class expects a generator to be provided at construction time. During the wait state, an element is pulled from the generator. This element can be anything (an array, an object, etc.). This provides a way to specify the goal of each trial (e.g., the direction in which to reach) in a somewhat generic way. Nearly every task, to date, inherits from Sequence and leverages this functionality.</p>
<p>In order to properly utilize <tt class="docutils literal"><span class="pre">Sequence</span></tt> functionality, a generator must be provided. The typical procedure involves a generation of a list of trial goals, which are yielded by a generator one at a time. These generator functions are naturally specific to each task. A reaching task may require specification of where to place all the targets. A grasping task may also specify targets, but perhaps in a different coordinate system or with more information necessary (e.g., the type of object to present).</p>
<p>Each task should specify the possible sequence generators in the class attribute <tt class="docutils literal"><span class="pre">sequence_generators</span></tt>, which must be specified for each task which inherits from Sequence. The list is empty by default and should be populated with the string names of functions to be used as sequence generators. Function names are assumed to be static methods of that same task class. An example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">riglib.experiment</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="k">class</span> <span class="nc">NewSequenceTask</span><span class="p">(</span><span class="n">Sequence</span><span class="p">):</span>
    <span class="n">sequence_generators</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;seq1&#39;</span><span class="p">,</span> <span class="s">&#39;seq2&#39;</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">seq1</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">length</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">seq2</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">length</span>

    <span class="c"># seq3 will not show up on the web interface because it is not in the list &#39;sequence_generators&#39;!</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">seq3</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">length</span>
</pre></div>
</div>
<p>The built-in python <a class="reference external" href="http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/">decorator</a> <tt class="docutils literal"><span class="pre">&#64;staticmethod</span></tt> will make the declared method a static method of the task.</p>
</div>
<div class="section" id="extending-tasks-with-features">
<h2>Extending tasks with &#8220;features&#8221;<a class="headerlink" href="#extending-tasks-with-features" title="Permalink to this headline">¶</a></h2>
<p>Features are partial tasks which can be used to extend a &#8220;base&#8221; task using multiple inheritance. This functionality can be used to extend behavior for a particular state of the task (e.g., deliver a juice reward during the &#8216;reward&#8217; state), create a &#8220;sink&#8221; to use for saving data to file (e.g., <tt class="docutils literal"><span class="pre">SaveHDF</span></tt>), etc.</p>
<p>Features should be added to the features module at the top-level of the bmi3d code. If the feature should also be selectable at runtime from the web interface, it should also be imported and added to featurelist.py. The dictionary &#8216;features&#8217; contained within that file is used to populate the list of features selectable. Not every feature needs to be a selectable feature. Sometimes the functionality may be useful for factoring out common but requried code between different tasks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To keep cross-task code dependencies minimal, manage <tt class="docutils literal"><span class="pre">featurelist.py</span></tt> carefully. If you only populate it with features that you actively need, that will minimize interference from other features that you don&#8217;t need. Including a feature which you don&#8217;t actually need may cause unnecessary errors due to the import of code, even if you don&#8217;t actually use the features in question</p>
</div>
<p><a class="reference internal" href="#tasks"><em>Tasks</em></a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tasks</a><ul>
<li><a class="reference internal" href="#defining-tasks">Defining tasks</a></li>
<li><a class="reference internal" href="#instantiating-tasks">Instantiating tasks</a></li>
<li><a class="reference internal" href="#order-of-operations-while-the-task-is-running">Order of operations while the task is running</a></li>
<li><a class="reference internal" href="#saving-task-data">Saving task data</a></li>
<li><a class="reference internal" href="#cleaning-up-tasks">Cleaning up tasks</a></li>
<li><a class="reference internal" href="#task-trials-and-logging">Task &#8220;trials&#8221; and logging</a></li>
<li><a class="reference internal" href="#extending-tasks-with-features">Extending tasks with &#8220;features&#8221;</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="prereqs.html"
                        title="previous chapter">Assumed Python knowledge</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="database.html"
                        title="next chapter">The Database</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/tasks.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="database.html" title="The Database"
             >next</a> |</li>
        <li class="right" >
          <a href="prereqs.html" title="Assumed Python knowledge"
             >previous</a> |</li>
        <li><a href="index.html">BMI3D 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, James Gao; 2015, James Gao, Helene Moorman, Suraj Gowda, Siddharth Dangi.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>